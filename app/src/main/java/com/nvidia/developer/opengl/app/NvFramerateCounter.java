////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2014, NVIDIA CORPORATION. All rights reserved.
// Copyright 2017 mzhg
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
// License for the specific language governing permissions and limitations
// under the License.
////////////////////////////////////////////////////////////////////////////////
package com.nvidia.developer.opengl.app;

import com.nvidia.developer.opengl.utils.NvStopWatch;

/**
 * Simple frame rate timer and reporter.
 * 
 * @author Nvidia 2014-9-13 15:45
 * 
 */
public class NvFramerateCounter {

	protected final NvStopWatch m_stopWatch = new NvStopWatch();
	protected int m_reportFrames = 120;
	protected int m_framesSinceReport;
	protected float m_reportRate = 2.0f;
	protected float m_meanFramerate;

	/**
	 * Frame delimiter.
	 * <p>
	 * Call at the end of each frame to mark the end of a frame.
	 * 
	 * @return true if the frame rate stats have been updated by this call and
	 *         should be printed/updated to the user as appropriate
	 */
	public boolean nextFrame() {
		if (!m_stopWatch.isRunning()) {
	        m_stopWatch.start();
	        m_framesSinceReport = 0;
	        return false;
	    }

	    m_framesSinceReport++;

	    // Only report if the number of frames AND the min time are exceeded
	    if (m_framesSinceReport >= m_reportFrames) {
	        float time = m_stopWatch.getTime();
	        if (time > m_reportRate) {
	            m_meanFramerate = m_framesSinceReport / time;
	            m_framesSinceReport = 0;
	            m_stopWatch.reset();
	            return true;
	        }
	    }

	    return false;
	}

	/**
	 * Restarts the counters - should be called when the app has come back after
	 * being paused, etc. Avoids incorrect stats generated by an extremely
	 * "long" frame (which was actually the app sleeping)
	 */
	public void reset() {
		m_framesSinceReport = 0;
	    m_stopWatch.stop();
	    m_stopWatch.reset();
	    m_stopWatch.start();
	}

	/**
	 * Mean frame rate since last report (the last time nextFrame returned
	 * "true")
	 * 
	 * @return the frame rate in frames per second
	 */
	public float getMeanFramerate() {
		return m_meanFramerate;
	}

	/**
	 * Set the report rate in frames.
	 * 
	 * @param frames
	 *            the minimum number of frames that must elapse between each
	 *            mean frame rate update (i.e. between calls to #nextFrame that
	 *            return true)
	 */
	public void setReportFrames(int frames) {
		m_reportFrames = frames;
	}

	/**
	 * Get the report rate in frames.
	 * 
	 * @return the minimum number of frames that must elapse between each mean
	 *         frame rate update (i.e. between calls to #nextFrame that return
	 *         true)
	 */
	public int getReportFrames() {
		return m_reportFrames;
	}

	/**
	 * Set the report rate in seconds
	 * 
	 * @param secs
	 *            the minimum number of seconds of wall-clock time that must
	 *            elapse between each mean frame rate update (i.e. between calls
	 *            to #nextFrame that return true)
	 */
	public void setMaxReportRate(float secs) {
		m_reportRate = secs;
	}

	/**
	 * Set the report rate in seconds
	 * 
	 * @return the minimum number of seconds of wall-clock time that must elapse
	 *         between each mean frame rate update (i.e. between calls to
	 *         #nextFrame that return true)
	 */
	public float getReportRate() {
		return m_reportRate;
	}

}
